{"version":3,"sources":["PathfinderVisualizer/Node.js","Algorithms/Dijkstra.js","Algorithms/AStar.js","PathfinderVisualizer/PathfinderVisualizer.js","Algorithms/BFS.js","Algorithms/DFS.js","Algorithms/Greedy.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","React","Component","Dikstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisited","allNodes","node","push","getAllNodes","length","sortUnvisited","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","neighbors","unvisitedNeighbors","filter","neighbor","previousNode","AStar","distanceToFinishNode","PathfindingVisualizer","initializeGrid","row_count","state","col_count","initialGrid","curr_row","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","Math","abs","isNode","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","handleMouseDown","bind","handleMouseLeave","toggleRunning","setState","nodeClassName","document","getElementById","newGrid","slice","isGridClear","getNewGridWithToggledWalls","clearGrid","algo","nextNodesStack","currNode","nextNode","BFS","pop","console","log","DFS","Greedy","nodesInShortestPathInOrder","currentNode","unshift","getNodesInShortestPathInOrder","animate","i","setTimeout","animateShortestPath","href","type","onClick","clearWalls","visualize","onMouseLeave","map","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.55836500.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css'\n\nexport default class Node extends React.Component {\n    render() {\n        const {\n            row,\n            col,\n            isStart,\n            isFinish,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n        } = this.props;\n\n        const extraClassName = \n        isFinish\n        ? 'node-finish'\n        : isStart\n        ? 'node-start'\n        : isWall\n        ? 'node-wall'\n        : '';\n\n        return (\n            <td\n            id={`node-${row}-${col}`}\n            className={`node ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={() => onMouseUp()}\n            ></td>\n        )\n    }\n}","export function Dikstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisited = getAllNodes(grid);\n\n    while (unvisited.length) {\n        sortUnvisited(unvisited);\n        const closestNode = unvisited.shift();\n        if (!closestNode.isWall) {\n            if (closestNode.distance === Infinity) return visitedNodesInOrder;\n            closestNode.isVisited = true;\n            visitedNodesInOrder.push(closestNode);\n            if (closestNode === finishNode) return visitedNodesInOrder;\n            updateUnvisitedNeighbors(closestNode, grid);\n        }\n\n    }\n\n}\n\nfunction getAllNodes(grid) {\n    const allNodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            allNodes.push(node);\n        }\n    }\n    return allNodes;\n}\n\nfunction sortUnvisited(unvisited) {\n    unvisited.sort((nodeA, nodeB) => {return nodeA.distance - nodeB.distance})\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\n","export function AStar(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisited = getAllNodes(grid);\n\n    while (unvisited.length) {\n        sortUnvisited(unvisited);\n        const closestNode = unvisited.shift();\n        if (!closestNode.isWall) {\n            if (closestNode.distance === Infinity) return visitedNodesInOrder;\n            closestNode.isVisited = true;\n            visitedNodesInOrder.push(closestNode);\n            if (closestNode === finishNode) {\n                return visitedNodesInOrder;}\n            updateUnvisitedNeighbors(closestNode, grid);\n        }\n\n    }\n\n}\n\nfunction getAllNodes(grid) {\n    const allNodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            allNodes.push(node);\n        }\n    }\n    return allNodes;\n}\n\nfunction sortUnvisited(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n        neighbor.previousNode = node;\n    }\n}\n\n","import React from 'react';\nimport './PathfinderVisualizer.css';\nimport Node from './Node';\nimport {BFS} from '../Algorithms/BFS.js';\nimport {DFS} from '../Algorithms/DFS.js';\nimport {Dikstra} from '../Algorithms/Dijkstra.js'\nimport {AStar} from '../Algorithms/AStar.js'\nimport {Greedy} from '../Algorithms/Greedy.js'\n\n\nexport default class PathfindingVisualizer extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            START_NODE_COL: 5,\n            START_NODE_ROW: 5,\n            FINISH_NODE_COL: 10,\n            FINISH_NODE_ROW: 5,\n            row_count: 25,\n            col_count: 35,\n            mouseIsPressed: false,\n            isRunning: false,\n            isStartNode: false,\n            isFinishNode: false,\n            isWallNode: false, \n            currRow: 0,\n            currCol: 0,\n        }\n        this.handleMouseDown = this.handleMouseDown.bind(this);\n        this.handleMouseLeave = this.handleMouseLeave.bind(this);\n        this.toggleRunning = this.toggleRunning.bind(this);\n    };\n\n    componentDidMount() {\n        const grid = this.initializeGrid();\n        this.setState({grid});\n    }\n\n    toggleRunning() {\n        this.setState({isRunning: !this.state.isRunning});\n    }\n\n    initializeGrid = (\n        row_count = this.state.row_count,\n        col_count = this.state.col_count,\n    ) => {\n        const initialGrid = [];\n        for (let row = 0; row < row_count; row++) {\n            const curr_row = [];\n            for (let col = 0; col < col_count; col++) {\n                curr_row.push(this.createNode(row, col));\n            }\n            initialGrid.push(curr_row)\n        }\n        return initialGrid\n    };\n\n    createNode = (row, col) => {\n        return {\n            row, \n            col,\n            isStart: \n                row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n            isFinish: \n                row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n            distance: Infinity,\n            distanceToFinishNode:\n                Math.abs(this.state.FINISH_NODE_ROW - row) + \n                Math.abs(this.state.FINISH_NODE_COL - col),\n            isVisited: false,\n            isWall: false,\n            previousNode: null,\n            isNode: true,\n        }\n    }\n\n    isGridClear() {\n        for (const row of this.state.grid) {\n            for (const node of row) {\n                const nodeClassName = document.getElementById(\n                    `node-${node.row}-${node.col}`,\n                ).className;\n                if (\n                    nodeClassName === 'node node-visited' || nodeClassName === 'node node-shortest-path'\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    clearGrid() {\n        if (!this.state.isRunning) {\n            const newGrid = this.state.grid.slice();\n            for (const row of newGrid) {\n                for (const node of row) {\n                    let nodeClassName = document.getElementById(\n                        `node-${node.row}-${node.col}`,\n                    ).className;\n                    if (\n                        nodeClassName !== 'node node-start' &&\n                        nodeClassName !== 'node node-finish' &&\n                        nodeClassName !== 'node node-wall'\n                    ) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n                        node.isVisited = false;\n                        node.distance = Infinity;\n                        node.distanceToFinishNode = \n                            Math.abs(this.state.FINISH_NODE_ROW - node.row) + \n                            Math.abs(this.state.FINISH_NODE_COL- node.col);\n                    }\n                    if (nodeClassName === 'node node-start') {\n                        node.isVisited = false;\n                        node.distance = Infinity;\n                        node.distanceToFinishNode = \n                            Math.abs(this.state.FINISH_NODE_ROW - node.row) + \n                            Math.abs(this.state.FINISH_NODE_COL - node.col);\n                        node.isStart = true;\n                        node.isWall = false;\n                        node.previousNode = null;\n                        node.isNode = true;\n                    }\n                    if (nodeClassName === 'node node-finish') {\n                        node.isVisited = false;\n                        node.distance = Infinity;\n                        node.distanceToFinishNode = \n                            0;\n                    }\n                }\n            }\n        }\n    }\n\n    clearWalls() {\n        if (!this.state.isRunning) {\n            const newGrid = this.state.grid.slice();\n            for (const row of newGrid) {\n                for (const node of row) {\n                    let nodeClassName = document.getElementById(\n                        `node-${node.row}-${node.col}`,\n                    ).className;\n                    if (nodeClassName === 'node node-wall') {\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n                        node.isWall = false;\n                    }\n                }\n            }\n        }\n    }\n\n    /******************** mouse events ********************/\n\n    handleMouseDown(row, col) {\n        if (!this.state.isRunning) {\n            if (this.isGridClear()) {\n                if (\n                    document.getElementById(`node-${row}-${col}`).className === 'node node-start'\n                ) {\n                    this.setState({\n                        mouseIsPressed: true,\n                        isStartNode: true,\n                        currRow: row,\n                        currCol: col\n                    })\n                } else if (\n                    document.getElementById(`node-${row}-${col}`).className === 'node node-finish'\n                ) {\n                    this.setState({\n                        mouseIsPressed: true,\n                        isFinishNode: true,\n                        currRow: row,\n                        currCol: col\n                    })\n                } else {\n                    const newGrid = getNewGridWithToggledWalls(this.state.grid, row, col);\n                    this.setState({\n                        grid: newGrid,\n                        mouseIsPressed: true,\n                        isWallNode: true,\n                        currRow: row, \n                        currCol: col,\n                    })\n                } \n            } else {\n                this.clearGrid();\n            }\n        }\n    }\n\n    handleMouseEnter(row, col) {\n        if (!this.state.isRunning) {\n            if (this.state.mouseIsPressed) {\n                const nodeClassName = document.getElementById(`node-${row}-${col}`).className;\n                if (this.state.isStartNode) {\n                    if (nodeClassName !== 'node node-wall') {\n                        const prevStartNode = this.state.grid[this.state.currRow][this.state.currCol];\n                        prevStartNode.isStart = false;\n                        document.getElementById(\n                            `node-${this.state.currRow}-${this.state.currCol}`\n                        ).className = 'node';\n                        this.setState({currRow: row, currCol: col});\n                        const currStartNode = this.state.grid[row][col];\n                        currStartNode.isStart = true;\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                    }\n                    this.setState({START_NODE_ROW: row, START_NODE_COL: col});\n                    // const currStartNode = this.state.grid[row][col];\n                    // currStartNode.isStart = true;\n                    // document.getElementById(`node-${row}-${col}`).className = 'node node-start'\n                    // this.setState({START_NODE_ROW: row, START_NODE_COL: col});\n                } else if (this.state.isFinishNode) {\n                    if (nodeClassName !== 'node node-wall') {\n                        const prevFinishNode = this.state.grid[this.state.currRow][this.state.currCol];\n                        prevFinishNode.isFinish = false;\n                        document.getElementById(`node-${row}-${col}`).className = 'node';\n                        this.setState({currRow: row, currCol: col});\n                        const currStartNode = this.state.grid[row][col];\n                        currStartNode.isFinish = true;\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                    }\n                    this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\n                } else if (this.state.isWallNode) {\n                    const newGrid = getNewGridWithToggledWalls(this.state.grid, row, col);\n                    this.setState({grid: newGrid});\n                }\n            }\n        }\n    }\n\n    handleMouseUp(row, col) {\n        if (!this.state.isRunning) {\n            this.setState({mouseIsPressed: false});\n            if (this.state.isStartNode) {\n                const isStartNode = !this.state.isStartNode;\n                this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\n            } else if (this.state.isFinishNode) {\n                const isFinishNode = !this.state.isFinishNode;\n                this.setState({\n                    isFinishNode,\n                    FINISH_NODE_COL: col,\n                    FINISH_NODE_ROW: row,\n                });\n            }\n            this.initializeGrid();\n        }\n    }\n\n    handleMouseLeave() {\n        if (this.state.isStartNode) {\n            const isStartNode = !this.state.isStartNode;\n            this.setState({\n                isStartNode, mouseIsPressed: false,\n            });\n        } else if (this.state.isFinishNode) {\n            const isFinishNode = !this.state.isFinishNode;\n            this.setState({\n                isFinishNode, mouseIsPressed: false,\n            });\n        } else if (this.state.isWallNode) {\n            const isWallNode = !this.state.isWallNode;\n            this.setState({\n                isWallNode, mouseIsPressed: false,\n            });\n            this.initializeGrid();\n        }\n    }\n\n    visualize(algo) {\n        if (!this.state.isRunning) {\n            this.clearGrid();\n            this.toggleRunning();\n            const {grid} = this.state;\n            const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            let visitedNodesInOrder;\n            switch (algo) {\n                case 'BFS':\n                    visitedNodesInOrder = BFS(grid, startNode, finishNode);\n                    break;\n                case 'DFS':\n                    visitedNodesInOrder = DFS(grid, startNode, finishNode);\n                    break;\n                case 'Dijkstra':\n                    visitedNodesInOrder = Dikstra(grid, startNode, finishNode);\n                    break;\n                case 'AStar':\n                    visitedNodesInOrder = AStar(grid, startNode, finishNode);\n                    break;\n                case 'Greedy':\n                    visitedNodesInOrder = Greedy(grid, startNode, finishNode);\n                    break;\n                default:\n                    break;\n            }\n            const nodesInShortestPathInOrder = getNodesInShortestPathInOrder(finishNode);\n            nodesInShortestPathInOrder.push('end');\n            this.animate(visitedNodesInOrder, nodesInShortestPathInOrder);\n        }\n    }\n\n    animate(visitedNodesInOrder, nodesInShortestPathInOrder) {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(()=> {\n                    this.animateShortestPath(nodesInShortestPathInOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(()=> {\n                const node = visitedNodesInOrder[i];\n                const nodeClassName = document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className;\n                if (\n                    nodeClassName !== 'node node-start' &&\n                    nodeClassName !== 'node node-finish'\n                ) {\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited'\n                }\n            }, 10 * i)\n        }\n    }\n\n    animateShortestPath(nodesInShortestPathInOrder) {\n        for (let i = 0; i < nodesInShortestPathInOrder.length; i++) {\n            if (nodesInShortestPathInOrder[i] === 'end') {\n                setTimeout(()=> {\n                    this.toggleRunning();\n                }, i * 50)\n            } else {\n                setTimeout(()=> {\n                    const node = nodesInShortestPathInOrder[i];\n                    const nodeClassName = document.getElementById(\n                        `node-${node.row}-${node.col}`,\n                    ).className;\n                    if (\n                        nodeClassName !== 'node node-start' &&\n                        nodeClassName !== 'node node-finish'\n                    ) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n                    }\n                }, i * 40)\n            }\n        }\n    }\n\n    render() {\n        const {grid, mouseIsPressed} = this.state;\n        return (\n            <div>\n                <nav className = 'navbar navbar-expand-lg navbar-dark bg-dark'>\n                    <a className = 'navbar-brand' href=\"/\">\n                        PATHFINDER <b>VISUALIZER</b>\n                    </a>\n                    <div className='ml-auto'>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-danger\"\n                    onClick={() => this.clearGrid()}>\n                    Clear Grid\n                    </button>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-secondary\"\n                    onClick={() => this.clearWalls()}>\n                    Clear Walls\n                    </button>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-info\"\n                    onClick={() => this.visualize('Dijkstra')}>\n                    Dijkstra's\n                    </button>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-info\"\n                    onClick={() => this.visualize('AStar')}>\n                    A*\n                    </button>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-info\"\n                    onClick={() => this.visualize('Greedy')}>\n                    Greedy\n                    </button>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-info\"\n                    onClick={() => this.visualize('BFS')}>\n                    Bread First Search\n                    </button>\n                    <button\n                    type=\"button\"\n                    className=\"btn btn-info\"\n                    onClick={() => this.visualize('DFS')}>\n                    Depth First Search\n                    </button>\n                    </div>\n                </nav>\n                <table\n                    className='grid-container'\n                    onMouseLeave={()=>this.handleMouseLeave()}>\n                    <tbody className='grid'>\n                        {grid.map((row, rowIdx) => {\n                            return (\n                                <tr key={rowIdx}>\n                                    {row.map((node, nodeIdx) => {\n                                        const {row, col, isFinish, isStart, isWall} = node;\n                                        return (\n                                            <Node\n                                            key={nodeIdx}\n                                            col={col}\n                                            isFinish={isFinish}\n                                            isStart={isStart}\n                                            isWall={isWall}\n                                            mouseIsPressed={mouseIsPressed}\n                                            onMouseDown={(row, col) =>\n                                            this.handleMouseDown(row, col)\n                                            }\n                                            onMouseEnter={(row, col) =>\n                                            this.handleMouseEnter(row, col)\n                                            }\n                                            onMouseUp={() => this.handleMouseUp(row, col)}\n                                            row={row}></Node>\n                                        )\n                                    })}\n                                </tr>\n                            )\n                        })}\n                    </tbody>\n                </table>\n            </div>\n        )\n    }\n}\n\nconst getNewGridWithToggledWalls = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isFinish && node.isNode) {\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n    }\n    return newGrid;\n}\n\nfunction getNodesInShortestPathInOrder(finishNode) {\n  const nodesInShortestPathInOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null && currentNode.previousNode !== null) {\n    nodesInShortestPathInOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathInOrder;\n}\n","export function BFS(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    let nextNodesStack = [startNode]\n    while (nextNodesStack.length) {\n        const currNode = nextNodesStack.shift();\n        if (currNode === finishNode) return visitedNodesInOrder;\n        if (\n            !currNode.isWall &&\n            (currNode.isStart || !currNode.isVisited)\n            ) {\n                currNode.isVisited = true;\n                visitedNodesInOrder.push(currNode);\n                const {col, row} = currNode;\n                let nextNode;\n                if (row>0) {\n                    nextNode = grid[row-1][col]\n                    if (!nextNode.isVisited) {\n                        nextNode.previousNode = currNode;\n                        nextNodesStack.push(nextNode);\n                    }\n                }\n                if (row < grid.length - 1) {\n                    nextNode = grid[row+1][col];\n                    if (!nextNode.isVisited) {\n                        nextNode.previousNode = currNode;\n                        nextNodesStack.push(nextNode);\n                    }\n                }\n                if (col > 0) {\n                    nextNode = grid[row][col - 1];\n                    if (!nextNode.isVisited) {\n                      nextNode.previousNode = currNode;\n                      nextNodesStack.push(nextNode);\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    nextNode = grid[row][col + 1];\n                    if (!nextNode.isVisited) {\n                      nextNode.previousNode = currNode;\n                      nextNodesStack.push(nextNode);\n                    }\n                  }\n            }\n        \n    }\n}","export function DFS(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    let nextNodesStack = [];\n    nextNodesStack.push(startNode);\n\n    while (nextNodesStack.length) {\n        const currNode = nextNodesStack.pop()\n        if (currNode === finishNode) {\n            console.log('dfs visited', visitedNodesInOrder)\n            return visitedNodesInOrder;\n        }\n\n        if (\n            !currNode.isWall &&\n            (currNode.isStart || !currNode.isVisited)\n            ) {\n                currNode.isVisited = true;\n                visitedNodesInOrder.push(currNode);\n                const {col, row} = currNode;\n                let nextNode;\n                if (row>0) {\n                    nextNode = grid[row-1][col]\n                    if (!nextNode.isVisited) {\n                        nextNode.previousNode = currNode;\n                        nextNodesStack.push(nextNode);\n                    }\n                }\n                if (row < grid.length - 1) {\n                    nextNode = grid[row+1][col];\n                    if (!nextNode.isVisited) {\n                        nextNode.previousNode = currNode;\n                        nextNodesStack.push(nextNode);\n                    }\n                }\n                if (col > 0) {\n                    nextNode = grid[row][col - 1];\n                    if (!nextNode.isVisited) {\n                      nextNode.previousNode = currNode;\n                      nextNodesStack.push(nextNode);\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    nextNode = grid[row][col + 1];\n                    if (!nextNode.isVisited) {\n                      nextNode.previousNode = currNode;\n                      nextNodesStack.push(nextNode);\n                    }\n                  }\n            }\n\n\n\n    }\n}","export function Greedy(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    let nextNodesStack = [startNode]\n    while (nextNodesStack.length) {\n        sortUnvisited(nextNodesStack)\n        const currNode = nextNodesStack.shift();\n        if (currNode === finishNode) return visitedNodesInOrder;\n        if (\n            !currNode.isWall &&\n            (currNode.isStart || !currNode.isVisited)\n            ) {\n                currNode.isVisited = true;\n                visitedNodesInOrder.push(currNode);\n                const {col, row} = currNode;\n                let nextNode;\n                if (row>0) {\n                    nextNode = grid[row-1][col]\n                    if (!nextNode.isVisited) {\n                        nextNode.previousNode = currNode;\n                        nextNodesStack.push(nextNode);\n                    }\n                }\n                if (row < grid.length - 1) {\n                    nextNode = grid[row+1][col];\n                    if (!nextNode.isVisited) {\n                        nextNode.previousNode = currNode;\n                        nextNodesStack.push(nextNode);\n                    }\n                }\n                if (col > 0) {\n                    nextNode = grid[row][col - 1];\n                    if (!nextNode.isVisited) {\n                      nextNode.previousNode = currNode;\n                      nextNodesStack.push(nextNode);\n                    }\n                  }\n                  if (col < grid[0].length - 1) {\n                    nextNode = grid[row][col + 1];\n                    if (!nextNode.isVisited) {\n                      nextNode.previousNode = currNode;\n                      nextNodesStack.push(nextNode);\n                    }\n                  }\n            }\n        \n    }\n}\n\nfunction sortUnvisited(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distanceToFinishNode - nodeB.distanceToFinishNode)\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + node.distanceToFinishNode;\n        neighbor.previousNode = node;\n    }\n}\n\n","import React from 'react';\nimport './App.css';\nimport PathfinderVisualizer from './PathfinderVisualizer/PathfinderVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfinderVisualizer></PathfinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}